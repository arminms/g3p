//
// Copyright (c) 2023-24 Armin Sobhani
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include <catch2/catch_all.hpp>
#include <g3p/gnuplot>

TEST_CASE("log() function", "[gnuplot][log]")
{   g3p::gnuplot gp;
    SECTION("no argument")
    {   auto log = gp.log();
        REQUIRE
        (   6 == std::count_if
            (   log.begin()
            ,   log.end()
            ,   [](int c) { return c == '\n'; }
            )
        );
    }
    SECTION("line count = 1")
    {   CHECK(" \n" == gp.log(1));
    }
    SECTION("line count = 6")
    {   CHECK(">> gnuplot log generated by g3p <<" == gp.log(6).substr(0, 34));
    }
}

TEST_CASE("version checking", "[gnuplot][version]")
{   g3p::gnuplot gp;
    SECTION("version")
    {   auto version = gp.version();
        CHECK(version >= 1.0f);
        CHECK(version  < 7.0f);
    }
    SECTION("patchlevel")
    {   auto patchlevel = gp.patchlevel();
        CHECK(patchlevel.size()  > 0);
        CHECK(patchlevel.size() <= 3);
    }
    SECTION("version string")
    {   auto v = gp.version_string();
        CHECK(v.size() > 0);
        CHECK(v.size() < 8);
        CHECK(2 == std::count(v.cbegin(), v.cend(), '.'));
    }
}

TEST_CASE("output stream operator", "[gnuplot]")
{   g3p::gnuplot gp;
    SECTION("whole output")
    {   auto out = gp >> 6;
        auto str = out.str();
        REQUIRE
        (   6 == std::count_if
            (   str.begin()
            ,   str.end()
            ,   [](char c) { return c == '\n'; }
            )
        );
    }
    SECTION("selective")
    {   std::string skip, g3p;
        gp >> 6 >> skip >> skip >> skip >> skip >> skip >> g3p;
        CHECK("by" == skip);
        CHECK("g3p" == g3p);
    }
}

TEST_CASE("passing strings", "[gnuplot][string]")
{   g3p::gnuplot gp;
    SECTION("string literal - c++ convention")
    {   gp << "t=" << "'test'" << "\n"
           << "print t\n"
        ;
        std::string t;
        gp >> 1 >> t;
        CHECK("test" == t);
    }
    SECTION("string literal - c convention")
    {   gp  ("t=%s", "'test'")
            ("print t")
        ;
        std::string t;
        gp >> 1 >> t;
        CHECK("test" == t);
    }
    SECTION("std::string - c++ convention")
    {   std::string t = "'test'";
        gp << "t=" << t << "\n"
           << "print t\n"
        ;
        gp >> 1 >> t;
        CHECK("test" == t);
    }
    SECTION("std::string - c convention")
    {   std::string t = "'test'";
        gp  ("t=%s", t.c_str())
            ("print t")
        ;
        gp >> 1 >> t;
        CHECK("test" == t);
    }
}

TEMPLATE_TEST_CASE("passing int values", "[gnuplot][int]", int, long)
{   typedef TestType T;
    T pi = T(314159), e = T(-271828);
    g3p::gnuplot gp;
    SECTION("c++ convention")
    {   gp << "x=" << pi << "; y=" << e << "\n"
           << "print x, y\n"
        ;
        T x, y;
        gp >> 1 >> x >> y;
        CHECK(pi == x);
        CHECK(e  == y);
    }
    SECTION("c convention")
    {   gp  ("x=%d; y=%d", pi, e)
            ("print x, y")
        ;
        T x, y;
        gp >> 1 >> x >> y;
        CHECK(pi == x);
        CHECK(e  == y);
    }
}

TEMPLATE_TEST_CASE("passing real values", "[gnuplot][real]", float, double)
{   typedef TestType T;
    T pi = T(3.141593), e = T(2.718282);
    g3p::gnuplot gp;
    SECTION("c++ convention")
    {   gp << "x="
           << pi
           << "; y="
           << e
           << "\nprint x, y\n"
        ;
        auto out = gp >> 1;
        CHECK(out.str() == "3.141593 2.718282\n");
        T x, y;
        out >> x >> y;
        CHECK(std::abs(pi - x) < 0.0001);
        CHECK(std::abs(e  - y) < 0.0001);
    }
    SECTION("c convention")
    {   gp  ("x=%f; y=%f", pi, e)
            ("print x, y")
        ;
        auto out = gp >> 1;
        CHECK(out.str() == "3.141593 2.718282\n");
        T x, y;
        out >> x >> y;
        CHECK(std::abs(pi - x) < 0.0001);
        CHECK(std::abs(e  - y) < 0.0001);
    }
}
